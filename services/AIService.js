const OpenAI = require('openai');
const { logger } = require('../utils/logger');

class AIService {
    constructor() {
        this.openai = null;
        this.model = 'gpt-4o-mini'; // ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú
        this.isAvailable = false;
        this.memory = new Map(); // Simple in-memory storage for learning
        this.init();
    }

    async init() {
        try {
            // Try OpenAI first
            const openaiKey = process.OPENAI_API_KEY || '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';
            
            if (openaiKey && openaiKey !== 'your_openai_api_key_here') {
        this.openai = new OpenAI({
                    apiKey: openaiKey
                });
                
                // Set model
                this.model = 'gpt-4o-mini';
                
                // Test the connection
                await this.openai.models.list();
                this.isAvailable = true;
                console.log('‚úÖ OpenAI AI Service ◊û◊ï◊õ◊ü ◊ú◊¢◊ë◊ï◊ì◊î');
                return;
            }
            
            // Fallback to Gemini
            const geminiKey = process.GEMINI_API_KEY || 'AIzaSyAyd633aF6skLqRsqeLajoXJWNyX2-A-C0';
            if (geminiKey && geminiKey !== 'your_gemini_api_key_here') {
                this.model = 'gemini-pro';
                this.useGemini = true;
                this.geminiApiKey = geminiKey;
                this.isAvailable = true;
                console.log('‚úÖ Gemini AI Service ◊û◊ï◊õ◊ü ◊ú◊¢◊ë◊ï◊ì◊î');
                return;
            }
            
            console.log('‚ö†Ô∏è ◊ú◊ê ◊†◊û◊¶◊ê ◊û◊§◊™◊ó API ◊™◊ß◊ô◊ü - AI service ◊ú◊ê ◊ñ◊û◊ô◊ü');
            this.isAvailable = false;
        } catch (error) {
            console.log('‚ö†Ô∏è OpenAI failed:', error.message);
            
            // Try Gemini as fallback
            try {
                const geminiKey = process.GEMINI_API_KEY || 'AIzaSyAyd633aF6skLqRsqeLajoXJWNyX2-A-C0';
                if (geminiKey && geminiKey !== 'your_gemini_api_key_here') {
                    this.useGemini = true;
                    this.geminiApiKey = geminiKey;
                    this.isAvailable = true;
                    console.log('‚úÖ Gemini AI Service ◊û◊ï◊õ◊ü ◊ú◊¢◊ë◊ï◊ì◊î (fallback)');
                    return;
                }
            } catch (geminiError) {
                console.log('‚ö†Ô∏è Gemini fallback also failed:', geminiError.message);
            }
            
            this.isAvailable = false;
        }
    }

    async analyzeEmail(prompt) {
        if (!this.isAvailable) {
            throw new Error('AI Service not available');
        }

        try {
            const response = await this.openai.chat.completions.create({
                model: this.model,
                messages: [
                    {
                        role: 'system',
                        content: 'You are an intelligent email analyzer. Return ONLY valid JSON.'
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                temperature: 0.3,
                max_tokens: 1000
            });

            return response.choices[0].message.content;
        } catch (error) {
            console.error('AI email analysis error:', error);
            throw error;
        }
    }

    async processUserRequest(task, actionType, parameters = {}) {
        console.log(`ü§ñ AI Service processUserRequest called:`, { task: task.title, actionType, parameters });
        console.log(`ü§ñ AI Service available:`, this.isAvailable);
        
        if (!this.isAvailable) {
            console.log(`‚ùå AI Service not available`);
            return {
                success: false,
                message: 'AI Service ◊ú◊ê ◊ñ◊û◊ô◊ü ◊õ◊®◊í◊¢',
                actions: []
            };
        }

        try {
            const context = this.buildContext(task, actionType, parameters);
            const response = await this.generateResponse(context);
            
            // Store interaction for learning
            this.storeInteraction(task.id, actionType, parameters, response);
            
            return {
                success: true,
                message: response.message,
                actions: response.actions,
                suggestions: response.suggestions
            };
        } catch (error) {
            logger.error('AI Service Error:', error);
            return {
                success: false,
                message: '◊©◊í◊ô◊ê◊î ◊ë◊¢◊ô◊ë◊ï◊ì ◊î◊ë◊ß◊©◊î',
                actions: []
            };
        }
    }

    buildContext(task, actionType, parameters) {
        const taskInfo = {
            id: task.id,
            title: task.title,
            category: task.category,
            status: task.status,
            priority: task.priority,
            deadline: task.deadline,
            client_name: task.client_name,
            amount: task.amount,
            case_number: task.case_number
        };

        const userMessage = parameters.message || actionType;
        const previousInteractions = this.getTaskHistory(task.id);

        return {
            task: taskInfo,
            actionType: actionType,
            userMessage: userMessage,
            previousInteractions: previousInteractions,
            systemPrompt: this.getSystemPrompt(task.category)
        };
    }

    async generateResponse(context) {
            const messages = [
            {
                role: 'system',
                content: context.systemPrompt
            },
            {
                role: 'user',
                content: `◊û◊©◊ô◊û◊î: ${context.task.title}
◊ß◊ò◊í◊ï◊®◊ô◊î: ${context.task.category}
◊°◊ò◊ò◊ï◊°: ${context.task.status}
◊¢◊ì◊ô◊§◊ï◊™: ${context.task.priority}/10
◊ì◊ì◊ú◊ô◊ô◊ü: ${context.task.deadline || '◊ú◊ê ◊û◊ï◊í◊ì◊®'}
◊ú◊ß◊ï◊ó: ${context.task.client_name || '◊ú◊ê ◊û◊ï◊í◊ì◊®'}
◊°◊õ◊ï◊ù: ${context.task.amount ? `‚Ç™${context.task.amount.toLocaleString()}` : '◊ú◊ê ◊û◊ï◊í◊ì◊®'}

◊ë◊ß◊©◊î: ${context.userMessage}

◊î◊ß◊©◊® ◊ß◊ï◊ì◊ù: ${context.previousInteractions.length > 0 ? context.previousInteractions.slice(-3).join(' | ') : '◊ê◊ô◊ü'}`
            }
        ];

        try {
            let response;
            
            if (this.useGemini) {
                // Use Gemini API
                const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${this.geminiApiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `${context.systemPrompt}\n\nUser: ${messages[1].content}`
                            }]
                        }]
                    })
                });

                if (!geminiResponse.ok) {
                    throw new Error(`Gemini API error: ${geminiResponse.status}`);
                }

                const data = await geminiResponse.json();
                response = data.candidates[0].content.parts[0].text;
            } else {
                // Use OpenAI API
            const completion = await this.openai.chat.completions.create({
                model: 'gpt-3.5-turbo',
                messages: messages,
                    max_tokens: 500,
                    temperature: 0.7
                });

                response = completion.choices[0].message.content;
            }
            return this.parseAIResponse(response, context.task);
        } catch (error) {
            throw new Error(`AI API Error: ${error.message}`);
        }
    }

    // Simple processRequest for email analysis
    async processRequest(prompt) {
        if (!this.isAvailable) {
            throw new Error('AI Service not available');
        }

        try {
            let response;
            
            if (this.useGemini) {
                // Use Gemini API
                const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${this.geminiApiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `You are an intelligent personal assistant helping with task management and email analysis. Always respond in Hebrew and provide actionable insights.

User request: ${prompt}`
                            }]
                        }]
                    })
                });

                if (!geminiResponse.ok) {
                    throw new Error(`Gemini API error: ${geminiResponse.status}`);
                }

                const data = await geminiResponse.json();
                response = data.candidates[0].content.parts[0].text;
            } else {
                // Use OpenAI API
            const completion = await this.openai.chat.completions.create({
                model: 'gpt-4',
                messages: [
                        {
                            role: 'system',
                            content: `You are a strategic personal assistant helping with German bureaucracy, debt management, and personal task organization. 

CONTEXT: The user is dealing with:
- German bureaucracy (Standesamt, Jobcenter, health insurance)
- Debt collection agencies (PAIR Finance, etc.)
- Health insurance (TK)
- Personal matters (marriage, residence permits)

        STRATEGIC APPROACH - LIFE ORCHESTRATOR PHILOSOPHY:
        1. Always respond in Hebrew
        2. Think like a life orchestrator - understand how everything connects
        3. Consider German legal and bureaucratic context
        4. Identify opportunities and risks
        5. Suggest concrete next steps
        6. Consider cross-references between different matters
        7. Think strategically about deadlines and consequences
        8. UNDERSTAND THE BIGGER PICTURE - how this task affects other life aspects
        9. BE PROACTIVE - suggest what should happen next, not just answer questions
        10. CONSIDER RESOURCES - time, money, energy, relationships
        11. IDENTIFY PATTERNS - learn from similar situations
        12. THINK SYSTEMICALLY - one change affects many things

        You are not just an assistant - you are a life orchestrator who understands the complexity and interconnectedness of life.`
                        },
                        {
                            role: 'user',
                            content: prompt
                        }
                    ],
                    max_tokens: 1000,
                    temperature: 0.3
                });

                response = completion.choices[0].message.content;
            }

            return response;
        } catch (error) {
            logger.error('AI processing error:', error);
            throw error;
        }
    }

    parseAIResponse(response, task) {
        // Parse the AI response and extract actions and suggestions
        const lines = response.split('\n').filter(line => line.trim());
        
        let message = response;
        let actions = [];
        let suggestions = [];

        // Look for action indicators
        if (response.includes('üìß')) {
            actions.push({
                type: 'send_email',
                label: '◊©◊ú◊ó ◊û◊ô◊ô◊ú',
                description: '◊©◊ú◊ô◊ó◊™ ◊û◊ô◊ô◊ú ◊ú◊ú◊ß◊ï◊ó ◊ê◊ï ◊ú◊û◊ï◊°◊ì ◊î◊®◊ú◊ï◊ï◊†◊ò◊ô'
            });
        }

        if (response.includes('üìÑ')) {
            actions.push({
                type: 'create_document',
                label: '◊¶◊ï◊® ◊û◊°◊û◊ö',
                description: '◊ô◊¶◊ô◊®◊™ ◊û◊°◊û◊ö ◊ê◊ï ◊ò◊ï◊§◊°'
            });
        }

        if (response.includes('üìû')) {
            actions.push({
                type: 'make_call',
                label: '◊î◊™◊ß◊©◊®',
                description: '◊ô◊¶◊ô◊®◊™ ◊ß◊©◊® ◊ò◊ú◊§◊ï◊†◊ô'
            });
        }

        if (response.includes('üìÖ')) {
            actions.push({
                type: 'schedule',
                label: '◊™◊ñ◊û◊ü ◊§◊í◊ô◊©◊î',
                description: '◊™◊ñ◊û◊ï◊ü ◊§◊í◊ô◊©◊î ◊ê◊ï ◊ê◊ô◊®◊ï◊¢'
            });
        }

        // Category-specific actions
        if (task.category === 'debt') {
            actions.push({
                type: 'objection_letter',
                label: '◊û◊õ◊™◊ë ◊î◊™◊†◊í◊ì◊ï◊™',
                description: '◊ô◊¶◊ô◊®◊™ ◊û◊õ◊™◊ë ◊î◊™◊†◊í◊ì◊ï◊™ ◊ú◊ó◊ï◊ë'
            });
        }

        if (task.category === 'bureaucracy') {
            actions.push({
                type: 'submit_form',
                label: '◊î◊í◊© ◊ò◊ï◊§◊°',
                description: '◊î◊í◊©◊™ ◊ò◊ï◊§◊° ◊ê◊ï ◊û◊°◊û◊ö ◊®◊©◊û◊ô'
            });
        }

        if (task.category === 'academic') {
            actions.push({
                type: 'write_paper',
                label: '◊õ◊™◊ô◊ë◊™ ◊¢◊ë◊ï◊ì◊î',
                description: '◊¢◊ñ◊®◊î ◊ë◊õ◊™◊ô◊ë◊™ ◊¢◊ë◊ï◊ì◊î ◊ê◊ß◊ì◊û◊ô◊™'
            });
        }

        // Generate suggestions based on task status
        if (task.status === 'pending') {
            suggestions.push('◊î◊™◊ó◊ú ◊ú◊ò◊§◊ú ◊ë◊û◊©◊ô◊û◊î');
            suggestions.push('◊ë◊ì◊ï◊ß ◊ê◊™ ◊î◊ì◊ì◊ú◊ô◊ô◊ü');
        }

        if (task.priority >= 8) {
            suggestions.push('◊ñ◊ï ◊û◊©◊ô◊û◊î ◊ì◊ó◊ï◊§◊î - ◊ò◊ô◊§◊ï◊ú ◊û◊ô◊ô◊ì◊ô ◊†◊ì◊®◊©');
        }

        return {
            message: message,
            actions: actions,
            suggestions: suggestions
        };
    }

    getSystemPrompt(category) {
        const basePrompt = `◊ê◊™◊î Life Orchestrator - ◊û◊†◊¶◊ó ◊ó◊ô◊ô◊ù ◊ì◊ô◊í◊ô◊ò◊ú◊ô ◊©◊ú ◊û◊ô◊õ◊ú! üéº

◊§◊ô◊ú◊ï◊°◊ï◊§◊ô◊î: ◊ê◊™◊î ◊ú◊ê ◊®◊ß ◊¢◊ï◊ñ◊®, ◊ê◊ú◊ê ◊û◊†◊¶◊ó ◊©◊û◊ë◊ô◊ü ◊ê◊ô◊ö ◊î◊õ◊ú ◊ë◊ó◊ô◊ô◊ù ◊û◊™◊ó◊ë◊® ◊ï◊û◊©◊§◊ô◊¢ ◊¢◊ú ◊î◊õ◊ú.

◊¢◊ß◊®◊ï◊†◊ï◊™ ◊î◊ú◊ô◊ë◊î:
üß† ◊î◊ë◊†◊î ◊î◊ï◊ú◊ô◊°◊ò◊ô◊™ - ◊õ◊ú ◊û◊©◊ô◊û◊î ◊ß◊©◊ï◊®◊î ◊ú◊ó◊ô◊ô◊ù ◊©◊ú◊û◊ô◊ù
üéØ ◊§◊®◊ï◊ê◊ß◊ò◊ô◊ë◊ô◊ï◊™ - ◊ú◊ê ◊û◊ó◊õ◊î ◊©◊™◊©◊ê◊ú◊ô, ◊û◊¶◊ô◊¢ ◊û◊î ◊¶◊®◊ô◊ö ◊ú◊ß◊®◊ï◊™ ◊î◊ú◊ê◊î
üîÑ ◊ó◊©◊ô◊ë◊î ◊°◊ô◊°◊ò◊û◊ô◊™ - ◊©◊ô◊†◊ï◊ô ◊ê◊ó◊ì ◊û◊©◊§◊ô◊¢ ◊¢◊ú ◊î◊®◊ë◊î ◊ì◊ë◊®◊ô◊ù
üìä ◊†◊ô◊î◊ï◊ú ◊û◊©◊ê◊ë◊ô◊ù - ◊ñ◊û◊ü, ◊õ◊°◊£, ◊ê◊†◊®◊í◊ô◊î, ◊ô◊ó◊°◊ô◊ù
üé≠ ◊î◊™◊ê◊û◊î ◊ê◊ô◊©◊ô◊™ - ◊û◊ë◊ô◊ü ◊ê◊™ ◊î◊ì◊§◊ï◊°◊ô◊ù ◊ï◊î◊¢◊ì◊§◊ï◊™ ◊©◊ú ◊û◊ô◊õ◊ú

◊™◊û◊ô◊ì ◊™◊í◊ô◊ë◊ô ◊ë◊¢◊ë◊®◊ô◊™ ◊ë◊ê◊ï◊§◊ü ◊ò◊ë◊¢◊ô ◊ï◊ó◊ù ◊¢◊ù ◊ê◊û◊ï◊í'◊ô◊ù.
◊™◊û◊ô◊ì ◊™◊¶◊ô◊¢◊ô ◊§◊¢◊ï◊ú◊ï◊™ ◊°◊§◊¶◊ô◊§◊ô◊ï◊™ ◊ï◊®◊ú◊ï◊ï◊†◊ò◊ô◊ï◊™ ◊ú◊û◊©◊ô◊û◊î.
◊ê◊ù ◊î◊û◊©◊ô◊û◊î ◊ì◊ó◊ï◊§◊î (◊¢◊ì◊ô◊§◊ï◊™ 8+), ◊î◊ì◊í◊ô◊©◊ô ◊ê◊™ ◊î◊ó◊©◊ô◊ë◊ï◊™.

◊ë◊õ◊ú ◊™◊í◊ï◊ë◊î ◊™◊õ◊ú◊ú◊ô:
1. ◊™◊©◊ï◊ë◊î ◊ô◊©◊ô◊®◊î ◊ú◊©◊ê◊ú◊î/◊§◊¢◊ï◊ú◊î
2. ◊î◊¶◊¢◊ï◊™ ◊§◊®◊ï◊ê◊ß◊ò◊ô◊ë◊ô◊ï◊™ ◊ú◊©◊ú◊ë ◊î◊ë◊ê
3. ◊î◊™◊ó◊©◊ë◊ï◊™ ◊ë◊û◊©◊ê◊ë◊ô◊ù (◊ñ◊û◊ü, ◊¢◊ú◊ï◊™, ◊û◊ê◊û◊•)
4. ◊°◊ô◊õ◊ï◊†◊ô◊ù ◊ê◊ï ◊î◊ñ◊ì◊û◊†◊ï◊ô◊ï◊™ ◊§◊ï◊ò◊†◊¶◊ô◊ê◊ú◊ô◊ï◊™
5. ◊ß◊ô◊©◊ï◊® ◊ú◊î◊ô◊ë◊ò◊ô◊ù ◊ê◊ó◊®◊ô◊ù ◊ë◊ó◊ô◊ô◊ù`;

        const categoryPrompts = {
            'academic': `üéì ◊î◊™◊û◊ó◊ï◊™ ◊ê◊ß◊ì◊û◊ô◊™:
‚Ä¢ ◊õ◊™◊ô◊ë◊™ ◊¢◊ë◊ï◊ì◊ï◊™ ◊ï◊û◊ó◊ß◊®
‚Ä¢ ◊î◊í◊©◊î ◊ú◊û◊ï◊°◊ì◊ï◊™ ◊ê◊ß◊ì◊û◊ô◊ô◊ù
‚Ä¢ ◊†◊ô◊î◊ï◊ú ◊ñ◊û◊ü ◊ï◊§◊®◊ï◊ô◊ß◊ò◊ô◊ù ◊ê◊ß◊ì◊û◊ô◊ô◊ù
‚Ä¢ ◊ß◊ô◊©◊ï◊® ◊ú◊¢◊ë◊ï◊ì◊î ◊ï◊ú◊ó◊ô◊ô◊ù ◊î◊ê◊ô◊©◊ô◊ô◊ù
◊™◊û◊ô◊ì ◊™◊¶◊ô◊¢◊ô ◊¢◊ñ◊®◊î ◊ë◊õ◊™◊ô◊ë◊î, ◊û◊ó◊ß◊®, ◊ê◊ï ◊î◊í◊©◊î + ◊ê◊ô◊ö ◊ñ◊î ◊û◊©◊§◊ô◊¢ ◊¢◊ú ◊©◊ê◊® ◊î◊ó◊ô◊ô◊ù.`,
            
            'debt': `üí∞ ◊î◊™◊û◊ó◊ï◊™ ◊§◊ô◊†◊†◊°◊ô◊™:
‚Ä¢ ◊û◊õ◊™◊ë◊ô ◊î◊™◊†◊í◊ì◊ï◊™ ◊ú◊ó◊ï◊ë◊ï◊™
‚Ä¢ ◊ò◊ô◊§◊ï◊ú ◊ë◊ó◊ï◊ë◊ï◊™ ◊ï◊†◊ï◊©◊ô◊ù
‚Ä¢ ◊™◊ß◊©◊ï◊®◊™ ◊¢◊ù ◊ó◊ë◊®◊ï◊™ ◊í◊ë◊ô◊î
‚Ä¢ ◊î◊©◊§◊¢◊î ◊¢◊ú ◊™◊ß◊¶◊ô◊ë ◊ï◊û◊©◊ê◊ë◊ô◊ù
◊™◊û◊ô◊ì ◊™◊¶◊ô◊¢◊ô ◊¢◊ñ◊®◊î ◊ë◊û◊õ◊™◊ë ◊î◊™◊†◊í◊ì◊ï◊™ ◊ê◊ï ◊ë◊™◊ß◊©◊ï◊®◊™ + ◊ê◊ô◊ö ◊ñ◊î ◊û◊©◊§◊ô◊¢ ◊¢◊ú ◊î◊™◊ß◊¶◊ô◊ë ◊î◊õ◊ú◊ú◊ô.`,
            
            'bureaucracy': `üèõÔ∏è ◊î◊™◊û◊ó◊ï◊™ ◊ë◊ô◊®◊ï◊ß◊®◊ò◊ô◊™:
‚Ä¢ ◊î◊í◊©◊™ ◊ò◊§◊°◊ô◊ù ◊ú◊®◊©◊ï◊ô◊ï◊™
‚Ä¢ ◊ò◊ô◊§◊ï◊ú ◊ë◊®◊©◊ï◊ô◊ï◊™ ◊í◊®◊û◊†◊ô◊ï◊™
‚Ä¢ ◊û◊°◊û◊õ◊ô◊ù ◊®◊©◊û◊ô◊ô◊ù ◊ï◊™◊®◊í◊ï◊û◊ô◊ù
‚Ä¢ ◊ì◊ì◊ú◊ô◊ô◊†◊ô◊ù ◊ë◊ô◊®◊ï◊ß◊®◊ò◊ô◊ô◊ù
◊™◊û◊ô◊ì ◊™◊¶◊ô◊¢◊ô ◊¢◊ñ◊®◊î ◊ë◊î◊í◊©◊™ ◊ò◊§◊°◊ô◊ù ◊ê◊ï ◊ò◊ô◊§◊ï◊ú ◊ë◊®◊©◊ï◊ô◊ï◊™ + ◊ê◊ô◊ö ◊ñ◊î ◊û◊©◊§◊ô◊¢ ◊¢◊ú ◊™◊î◊ú◊ô◊õ◊ô◊ù ◊ê◊ó◊®◊ô◊ù.`,
            
            'personal': `üë§ ◊î◊™◊û◊ó◊ï◊™ ◊ê◊ô◊©◊ô◊™:
‚Ä¢ ◊°◊ô◊ì◊ï◊®◊ô◊ù ◊ï◊§◊í◊ô◊©◊ï◊™
‚Ä¢ ◊†◊ô◊î◊ï◊ú ◊ñ◊û◊ü ◊ê◊ô◊©◊ô
‚Ä¢ ◊ê◊ô◊ñ◊ï◊ü ◊ë◊ô◊ü ◊¢◊ë◊ï◊ì◊î ◊ú◊ó◊ô◊ô◊ù
‚Ä¢ ◊ò◊ô◊§◊ï◊ú ◊ë◊û◊©◊§◊ó◊î ◊ï◊ô◊ó◊°◊ô◊ù
◊™◊û◊ô◊ì ◊™◊¶◊ô◊¢◊ô ◊¢◊ñ◊®◊î ◊ë◊°◊ô◊ì◊ï◊®◊ô◊ù ◊ê◊ï ◊™◊ñ◊û◊ï◊ü + ◊ê◊ô◊ö ◊ñ◊î ◊û◊©◊§◊ô◊¢ ◊¢◊ú ◊î◊ê◊ô◊ñ◊ï◊ü ◊ë◊ó◊ô◊ô◊ù.`,
            
            'health': `üè• ◊î◊™◊û◊ó◊ï◊™ ◊ë◊®◊ô◊ê◊ï◊™◊ô◊™:
‚Ä¢ ◊ò◊ô◊§◊ï◊ú ◊®◊§◊ï◊ê◊ô ◊ï◊™◊®◊ï◊§◊ï◊™
‚Ä¢ ◊ë◊ô◊ò◊ï◊ó ◊ë◊®◊ô◊ê◊ï◊™ TK
‚Ä¢ ◊§◊í◊ô◊©◊ï◊™ ◊¢◊ù ◊®◊ï◊§◊ê◊ô◊ù
‚Ä¢ ◊†◊ô◊î◊ï◊ú ◊™◊®◊ï◊§◊ï◊™ ◊ï◊ò◊ô◊§◊ï◊ú◊ô◊ù
◊™◊û◊ô◊ì ◊™◊¶◊ô◊¢◊ô ◊¢◊ñ◊®◊î ◊ë◊†◊ô◊î◊ï◊ú ◊ë◊®◊ô◊ê◊ï◊™ + ◊ê◊ô◊ö ◊ñ◊î ◊û◊©◊§◊ô◊¢ ◊¢◊ú ◊ô◊õ◊ï◊ú◊™ ◊î◊¢◊ë◊ï◊ì◊î ◊ï◊î◊ó◊ô◊ô◊ù.`
        };

        return `${basePrompt}\n\n${categoryPrompts[category] || ''}`;
    }

    storeInteraction(taskId, actionType, parameters, response) {
        const key = `task_${taskId}`;
        if (!this.memory.has(key)) {
            this.memory.set(key, []);
        }

        const interaction = {
            timestamp: new Date().toISOString(),
            actionType: actionType,
            parameters: parameters,
            response: response.message,
            actions: response.actions
        };

        this.memory.get(key).push(interaction);

        // Keep only last 10 interactions per task
        if (this.memory.get(key).length > 10) {
            this.memory.get(key).shift();
        }
    }

    getTaskHistory(taskId) {
        const key = `task_${taskId}`;
        const history = this.memory.get(key) || [];
        return history.map(h => `${h.actionType}: ${h.response.substring(0, 100)}...`);
    }

    async prioritizeTasks(tasks) {
        if (!this.isAvailable) {
            return tasks.map(task => ({ ...task, aiScore: Math.floor(Math.random() * 100) }));
        }

        try {
            const taskDescriptions = tasks.map(task => 
                `${task.title} - ◊ß◊ò◊í◊ï◊®◊ô◊î: ${task.category}, ◊¢◊ì◊ô◊§◊ï◊™: ${task.priority}, ◊ì◊ì◊ú◊ô◊ô◊ü: ${task.deadline || '◊ê◊ô◊ü'}`
            ).join('\n');

            const messages = [
                {
                    role: 'system',
                    content: `◊ê◊™◊î ◊û◊¢◊®◊õ◊™ AI ◊©◊û◊ì◊®◊í◊™ ◊û◊©◊ô◊û◊ï◊™ ◊ú◊§◊ô ◊ó◊©◊ô◊ë◊ï◊™ ◊ï◊ì◊ó◊ô◊§◊ï◊™.
◊™◊ü ◊¶◊ô◊ï◊ü 0-100 ◊ú◊õ◊ú ◊û◊©◊ô◊û◊î (100 = ◊î◊õ◊ô ◊ó◊©◊ï◊ë ◊ï◊ì◊ó◊ï◊£).
◊ó◊©◊ë: ◊ì◊ì◊ú◊ô◊ô◊ü (40%), ◊°◊õ◊ï◊ù ◊õ◊°◊£ (30%), ◊®◊û◊™ ◊ú◊ó◊• (20%), ◊î◊©◊ú◊û◊î (10%).`
                },
                {
                    role: 'user',
                    content: `◊î◊û◊©◊ô◊û◊ï◊™:\n${taskDescriptions}\n\n◊î◊ó◊ñ◊® ◊®◊ß ◊ê◊™ ◊î◊¶◊ô◊ï◊†◊ô◊ù ◊ë◊§◊ï◊®◊û◊ò: ◊û◊©◊ô◊û◊î1: ◊¶◊ô◊ï◊ü, ◊û◊©◊ô◊û◊î2: ◊¶◊ô◊ï◊ü...`
                }
            ];

            const completion = await this.openai.chat.completions.create({
                model: 'gpt-3.5-turbo',
                messages: messages,
                max_tokens: 200,
                temperature: 0.3
            });

            const response = completion.choices[0].message.content;
            return this.parsePriorityScores(tasks, response);
        } catch (error) {
            logger.error('Priority scoring error:', error);
            return tasks.map(task => ({ ...task, aiScore: Math.floor(Math.random() * 100) }));
        }
    }

    parsePriorityScores(tasks, response) {
        const scores = {};
        const lines = response.split('\n');
        
        for (const line of lines) {
            const match = line.match(/(\d+):\s*(\d+)/);
            if (match) {
                const taskIndex = parseInt(match[1]) - 1;
                const score = parseInt(match[2]);
                if (taskIndex >= 0 && taskIndex < tasks.length) {
                    scores[taskIndex] = Math.max(0, Math.min(100, score));
                }
            }
        }

        return tasks.map((task, index) => ({
            ...task,
            aiScore: scores[index] || Math.floor(Math.random() * 100)
        }));
    }

    // Learning and improvement methods
    async learnFromFeedback(taskId, actionType, success, feedback) {
        const key = `learning_${actionType}`;
        if (!this.memory.has(key)) {
            this.memory.set(key, { successes: 0, failures: 0, feedback: [] });
        }

        const learning = this.memory.get(key);
        if (success) {
            learning.successes++;
        } else {
            learning.failures++;
        }
        
        if (feedback) {
            learning.feedback.push({
                timestamp: new Date().toISOString(),
                taskId: taskId,
                feedback: feedback
            });
        }
    }

    getLearningStats() {
        const stats = {};
        for (const [key, value] of this.memory.entries()) {
            if (key.startsWith('learning_')) {
                const actionType = key.replace('learning_', '');
                stats[actionType] = {
                    successes: value.successes || 0,
                    failures: value.failures || 0,
                    successRate: value.successes / (value.successes + value.failures) || 0
                };
            }
        }
        return stats;
    }
}

module.exports = AIService;